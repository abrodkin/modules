##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		config/%M%
#   Revision:		%I%
#   First Edition:	95/12/06
#   Last Mod.:		%U%, %G%
#
#   Authors:		Jens Hamisch, Jens.Hamisch@Strawberry.COM
#
#   Description:	Testuite initialization
#   Command:
#   Sub-Command:
#
#   Comment:	%C{
#			Initialization of the testsuite. Definition of
#			globally used start procedures for the test
#			target.
#		}C%
#
##############################################################################

#
# default shell is the bourne shell
#

proc default_shell {} {
    global shell

    if ![info exists shell] then {
	set shell "sh"
    }
}

#
# the default for the modulecmd binary is the one in the upper directory
# if it doesn't exist, look up the serach path in order to locate one.
#

proc default_modulecmd {} {
    global MODULECMD
    global verbose

    if ![info exists MODULECMD] then {
	if [file exists "./modulecmd"] then {
	    set MODULECMD "./modulecmd"
	} else {
	    set MODULECMD [which modulecmd]
	    if { $verbose > 0 } {
		send_user "using 'modulecmd' from search path"
	    }
	}
    }

    if ![file exists $MODULECMD] then {
	fail "No 'modulecmd' found"
	exit -1
    }
}

#
# modulecmd_exit -- cleanup
#

proc modulecmd_exit {} {
#not applicable
}

#
# modulecmd_start -- start modulecmd running
# Since modulecmd writes to both streams, stdout and stderr, a catcher
# has to be installed in order to scan both 
#

proc modulecmd_start {command} {
    global MODULECMD
    global verbose
    global shell
    global comp_output
    global comp_error

    if ![info exists command] then {
	unresolved "internal testsuite error: no module command specified"
    }

    default_shell 
    default_modulecmd

    if { $verbose > 0 } {
	send_user "starting $MODULECMD $shell $command\n"
    }

    catch {set comp_output [eval exec $MODULECMD $shell [split $command { }]]
	} comp_error
}

#
# modulecmd__ -- start modulecmd running
#   (same as above but no verbose output)

proc modulecmd__ {command} {
    global MODULECMD
    global verbose
    global shell
    global comp_output
    global comp_error

    if ![info exists command] then {
	unresolved "internal testsuite error: no module command specified"
    }

    default_shell 
    default_modulecmd

    catch {set comp_output [eval exec $MODULECMD $shell [split $command { }]]
	} comp_error
}

#
# modulecmd_version -- extract and print the version number of modulecmd
#

proc modulecmd_version {} {
    global MODULECMD
    global shell
    global comp_output
    global comp_error

    default_shell 
    default_modulecmd

    modulecmd_start help
    regexp {[ \t\n]+Modules Release ([-0-9a-zA-Z\.]+)} \
	$comp_error tmp version 

    set comp_output "$version"
}

#
# modulecmd_load -- loads the program
#

proc modulecmd_load { arg } {
#   not applicable
}
