##############################################################################
#   Modules Revision 3.0
#   Providing a flexible user environment
#
#   File:		modules.00-init/%M%
#   Revision:		%I%
#   First Edition:	95/12/06
#   Last Mod.:		%U%, %G%
#
#   Authors:		Jens Hamisch, Jens.Hamisch@Strawberry.COM
#
#   Description:	Test procedures
#   Command:
#   Sub-Command:
#
#   Comment:	%C{
#			Defines the testprocedures for probing the outputs
#			on stdout and stderr of the test target
#		}C%
#
##############################################################################

#
# some tests only apply if the configure option is enabled or not
#   look at ./modulecmd --version for examples
#   (e.g. version_test("XXX=undef") returns 0 or 1 if the string is found)
# 	if { [ version_test "XXX=1" ] } {
#	} else {
#	}
#
proc version_test {which} {
    global comp_output
    global comp_error
    global verbose

    if { $verbose > 1 } {
	send_user "   ...  version_test($which)\n"
    }
    set comp_output ""
    set comp_error ""

    if { ![info exists which] } {
	unresolved "version_test ($which) internal error"
    }

    modulecmd__ "--version"

    if { ![regexp ".*$which.*" $comp_output] } {
	if { $verbose > 1 } {
	    send_user "version_test: 0\n"
	}
	return 0
    } else {
	if { $verbose > 1 } {
	    send_user "version_test: 1\n"
	}
	return 1
    }
}

#
# Test subprocedure
#

proc _test_sub {test_shell cmd answer} {
    global comp_output
    global comp_error
    global shell
    global verbose

    if { $verbose > 0 } {
	send_user "   ...  Testing 'modulecmd $test_shell $cmd'\n"
    }
    set comp_output ""
    set comp_error ""

    if { ![info exists test_shell] || ![info exists answer] ||
	 ![info exists cmd] } {
	unresolved "$cmd ($test_shell) internal error"
    }

    set shell $test_shell
    modulecmd_start "$cmd"

    if { $verbose > 1 } {
	send_user "OUT: '$comp_output'\n"
	send_user "ERR: '$comp_error'\n"
    }
}

#
# Test procedure for matching with regular expressions
#

proc test_cmd_re {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose
    
    _test_sub $test_shell "$cmd" "$answer"

    if { ![regexp $answer $comp_output] } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "OUT: '$comp_output'\n"
	    send_user "EXP (re): '$answer'\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
#  Test procedure for full text matching
#

proc test_cmd {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose

    _test_sub $test_shell "$cmd" "$answer"

    if { $comp_output != "$answer" } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "OUT: '$comp_output'\n"
	    send_user "EXP: '$answer'\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
# Test procedure for matching with regular expressions in the error output
#

proc testerr_cmd_re {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose
    
    _test_sub $test_shell "$cmd" "$answer"

    if { ![regexp $answer $comp_error] } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "ERR: '$comp_error'\n"
	    send_user "EXP (re): '$answer'\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

#
#  Test procedure for full text matching in the error output
#

proc testerr_cmd {test_shell cmd answer} {
    global comp_output
    global comp_error
    global verbose

    _test_sub $test_shell "$cmd" "$answer"

    if { $comp_error != "$answer" } {
	fail "$cmd ($test_shell)"
	if { $verbose > 0 } {
	    send_user "ERR: '$comp_error'\n"
	    send_user "EXP: '$answer'\n"
	}
    } else {
	pass "$cmd ($test_shell)"
    }
}

